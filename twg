#! /usr/bin/env wish

package require Tcl 8.6 ;# try(n)
package require Tk 8.5  ;# ttk

package require bcrypt_pbkdf 0.1

# predicates (-p) generally have traces on them to disable/enable some widget(s)
set ifnum 0
set address {}
set passphrase {}
set portp {} ;# authoritative value after UI definition
set port {}

# parallel with one element for each peer
array set peers {}
array set aips {}
array set epp {}
array set endpoints {}
array set ports {}
array set psks {}
array set pskp {}

# This should be seen as a lousy sort of insurance, making it at least possible
# that brute-forcing a less than stellar password will not be cheaper than just
# brute-forcing the 32-octet key. This value takes a bit over one second on my
# Thinkpad X61 (Core 2 Duo T7300), as opposed to not quite thirteen microseconds
# to generate a random base64 string from tcl with
# `binary encode base64 [arc4random::arc4random bytes 32]`.
set BCRYPT_PBKDF_ROUNDS 100

# Should return a base64-encoded wireguard private key.
proc genkey {} {
	# DANGER: This is not really what bcrypt_pbkdf is meant for. I don't know
	# why this is wrong, or if it is for sure, but it probably is.
	# At the very least, this risks generating a crappy key if the user provides
	# a crappy passphrase.

	# This is probably a bad plan too, but as far as I can understand the
	# concept of a salt is not useful here, because we're not trying to hide a
	# secret, the hash we're generating *is* a secret. bcrypt_pbkdf sensibly
	# (but unhelpfully if you want to be stupid) refuses to cooperate if you
	# give it an empty salt, so we simply declare half our passphrase to be a
	# "salt".
	set half [expr {entier([string length $::passphrase] / 2)}]
	set notsalt [string range $::passphrase $half end]
	set pass [string range $::passphrase 0 $half-1]

	return [binary encode base64 [bcrypt_pbkdf $pass $notsalt 32 $::BCRYPT_PBKDF_ROUNDS]]
}

proc ifconfig {args} {
	exec doas /sbin/ifconfig {*}$args
}

# create and configure the interface
proc up {} {
	set if wg$::ifnum

	ifconfig $if create
	ifconfig $if $::address
	ifconfig $if wgkey [genkey]

	if {$::portp} {
		ifconfig $if wgport $::port
	}

	foreach peerid [array names ::peers] {
		ifconfig $if wgpeer $::peers($peerid) wgaip $::aips($peerid)

		if {$::epp($peerid)} {
			ifconfig $if wgpeer $::peers($peerid) wgendpoint \
				$::endpoints($peerid) $::ports($peerid)
		}

		if {$::pskp($peerid)} {
			ifconfig $if wgpeer $::peers($peerid) wgpsk $::psks($peerid)
		}
	}
}

# destroy... well, read it, okay?
proc down {} {
	ifconfig wg$::ifnum destroy
}

# generate a unique ad-hoc symbol for something (in particular this is
# responsible for generating the indices into the parallel arrays that represent
# wireguard peers)
set gensym_index 0
proc gensym {{base gensym}} { return "$base[incr ::gensym_index]" }

# generate a ttk::separator, nice for use inline in a layout manager invocation
proc mksep {b {o horizontal}} {
	return [ttk::separator $b.[gensym mksep] -orient $o]
}

# add a new peer's worth of widgets under the frame $w
proc addpeer {w} {
	set f [ttk::frame $w.[set peerid [gensym peer]]]

	ttk::label $f.pubkeylabel -text "Public key:"
	ttk::entry $f.pubkey -textvariable ::peers($peerid)

	ttk::label $f.aiplabel -text "Allowed addresses:"
	ttk::entry $f.aip -textvariable ::aips($peerid)

	# optional block for the endpoint
	ttk::checkbutton $f.epp -text "Initial endpoint:" -variable ::epp($peerid)
	ttk::frame $f.ep -relief raised
	ttk::label $f.ep.addrlab -text "Address:"
	ttk::entry $f.ep.addr -textvariable ::endpoints($peerid)
	ttk::label $f.ep.portlab -text "Port:"
	ttk::spinbox $f.ep.port -from 0 -to 65535 -increment 1 \
		-textvariable ::ports($peerid)
	grid $f.ep.addrlab $f.ep.addr -sticky ew
	grid $f.ep.portlab $f.ep.port -sticky ew
	grid columnconfigure $f.ep 1 -weight 1

	set ::epp($peerid) 0

	# optional block for the PSK
	ttk::frame $f.psk
	ttk::label $f.psklab -text "PSK:"
	ttk::entry $f.psk.en -textvariable ::psks($peerid)
	ttk::checkbutton $f.psk.p -text "Enabled?" -variable ::pskp($peerid)
	grid $f.psk.p $f.psk.en -sticky ew
	grid columnconfigure $f.psk 1 -weight 1

	set ::pskp($peerid) 0

	ttk::button $f.remove -text "Remove peer" -command [list apply { {f id} {
		destroy $f
		array unset peers $id
		array unset ports $id
		array unset aips $id
		array unset epp $id
		array unset endpoints $id
	}} $f $peerid]

	grid $f.pubkeylabel $f.pubkey   -sticky ew
	grid $f.aiplabel    $f.aip      -sticky ew
	grid $f.epp         x           -sticky ew
	grid $f.ep          -           -sticky nsew
	grid $f.psklab      $f.psk      -sticky ew
	grid x              $f.remove   -sticky e

	grid columnconfigure $f 0 -weight 0
	grid columnconfigure $f 1 -weight 1

	grid $f -padx [tk scaling] -pady [tk scaling] -sticky ew
	grid columnconfigure $w 0 -weight 1

	return $f
}

ttk::frame .f

ttk::label .f.iflabel -text "Interface #:"
ttk::spinbox .f.ifnum -from 0 -to 99 -increment 1 -textvariable ::ifnum

ttk::label .f.addrlabel -text "Address:"
ttk::entry .f.addrentry -textvariable ::address

# the vague and ominous plan is to feed this to bcrypt_pbkdf or so
ttk::label .f.pplabel -text "Passphrase:"
ttk::entry .f.ppentry -textvariable ::passphrase -show *

# optional block for the wireguard UDP port
ttk::labelframe .f.port -text "Port:"
ttk::radiobutton .f.port.auto -text "Choose automatically" \
	-variable ::portp -value no
ttk::radiobutton .f.port.manual -text "Manual:" \
	-variable ::portp -value yes
ttk::entry .f.port.en -textvariable ::port
grid .f.port.auto    -         -sticky ew
grid .f.port.manual .f.port.en -sticky ew
grid columnconfigure .f.port 1 -weight 1

ttk::labelframe .f.peers -text "Peers:"

ttk::button .f.addpeer -text "Add peer" -command { addpeer .f.peers }

ttk::button .f.up -text "Bring up" -command {
	try {
		up
	} on error {err opts} {
		# don't leave an interface half-configured
		down
		return -options $opts $err
	}
}
ttk::button .f.down -text "Tear down" -command down

grid .f.iflabel   .f.ifnum     -sticky ew
grid .f.addrlabel .f.addrentry -sticky ew
grid .f.pplabel   .f.ppentry   -sticky ew
grid .f.port      -            -sticky nsew
grid .f.peers     -            -sticky nsew -padx [expr {[tk scaling] * 4}]
grid x            .f.addpeer   -sticky e
grid [mksep .f]   -            -sticky ew -pady [tk scaling]
grid .f.up        .f.down

grid configure .f.up   -sticky w
grid configure .f.down -sticky e

grid columnconfigure .f 0 -weight 0
grid columnconfigure .f 1 -weight 1

pack .f -expand yes -fill both

# trace to enable/disable some widget based on the value assigned to a
# predicate; [string map] :w to something appropriate
set pwidget {apply {{var index op} {
	if {[array exists $var]} {
		set acc [set var]($index)
	} else {
		set acc $var
	}

	if {[set $acc]} {
		:w state !disabled
	} else {
		:w state disabled
	}
}}}

trace add variable ::portp write [string map {:w .f.port.en} $pwidget]
# note that $index will resolve in the pwidget lambda's scope
trace add variable ::epp   write [string map {:w .f.peers.$index.ep.addr} $pwidget]
trace add variable ::epp   write [string map {:w .f.peers.$index.ep.port} $pwidget]
trace add variable ::pskp  write [string map {:w .f.peers.$index.psk.en} $pwidget]
# reset to trick the trace into firing
set ::portp no

.f.addpeer invoke
